<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data-wrangling on R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Rémi Mahmoud" />
    <link href="data_wrangling_slides_files/remark-css/default.css" rel="stylesheet" />
    <link href="data_wrangling_slides_files/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Data-wrangling on R
### Rémi Mahmoud

---

&lt;style&gt;

.bottom {
  margin: 0;
  position: absolute;
  top: 80%;
  left: 50%;
  -ms-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
}

@media print {
  .has-continuation {
    display: block !important;
  }
}

&lt;/style&gt;



&lt;style type="text/css"&gt;
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;



# Who is talking ? 

.pull-left[![](lesson_figures/mahmoud_photo.png)]


.pull-right[![](lesson_figures/camembert.jpg)]


.center[![](lesson_figures/inrae.png)]

---

# What is data-wrangling ?

--

![](lesson_figures/data-science-wrangle.png)
--

* data-wrangling is the set of operations on __raw__ data that leads to __non messy__ (tidy) data.




---

# What we will talk about today

--

* Data importation

--

* Manipulate data (filtering, arranging data etc.)

--

* Tidy data


--

# What we will NOT talk about today

--

* Dealing with missing values / outliers


---


# Framework

All manipulations will be done in the `tidyverse` framework.


--

Hence, you should, if not already done, run the following command in R __NOW__


```r
install.packages("tidyverse")
```


---

# Tidyverse = Tidy universe

Tidyverse is a set of packages with differents purposes, that share the same syntax and that are designed to work in a complementary way  

--

.center[![](lesson_figures/tidyverse.png)]



---

You can list the packages available in the `tidyverse` by running the following command:


```r
tidyverse::tidyverse_packages()
```

```
##  [1] "broom"      "cli"        "crayon"     "dbplyr"     "dplyr"      "forcats"    "ggplot2"   
##  [8] "haven"      "hms"        "httr"       "jsonlite"   "lubridate"  "magrittr"   "modelr"    
## [15] "pillar"     "purrr"      "readr"      "readxl"     "reprex"     "rlang"      "rstudioapi"
## [22] "rvest"      "stringr"    "tibble"     "tidyr"      "xml2"       "tidyverse"
```

--

You can see that `ggplot2` that you discovered yesterday belongs to the `tidyverse`. But there are *many other packages* ! 

--

For instance, the `forcats` package allows to work in a convenient way with factors, `lubridate` with dates etc. .

--

For now, we will take a closer look to the `readr` and to a lesser extent `readxl` packages. These packages are useful to __import__ data.



---

# Import data with `readr`

The `read_csv` functon of `readr` allows to read csv files.

--

```r
data_work &lt;- readr::read_csv('../data/iris.csv')
```

```
## Parsed with column specification:
## cols(
##   Sepal.Length = col_double(),
##   Sepal.Width = col_double(),
##   Petal.Length = col_double(),
##   Petal.Width = col_double(),
##   Species = col_character()
## )
```

`read_csv` is faster than base R `read.csv` and it parses well different types of columns.



---

This function has also other arguments that may be useful for you when using it:

--

* `skip` to specify the number of lines to skip before reading the file
* `na` to specify what should be considered as `NA` (for ex: you could put `na = "Not answered"`)
* `col_names` to specify the names of the columns you want to have in your dataset.
* See `?read_csv` for other arguments.

---

# Tibble vs dataframe

Lets take a look at the data we have imported.


```r
head(data_work)
```

```
## # A tibble: 6 x 5
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  
## 1          5.1         3.5          1.4         0.2 setosa 
## 2          4.9         3            1.4         0.2 setosa 
## 3          4.7         3.2          1.3         0.2 setosa 
## 4          4.6         3.1          1.5         0.2 setosa 
## 5          5           3.6          1.4         0.2 setosa 
## 6          5.4         3.9          1.7         0.4 setosa
```

--

Note the particular output of the print:

* *A tibble*
* The  type of each column is written under each col_name

---

### The tibble is an alternative to the classical `data.frame` of base R

--

As part of the tidyverse, it is mainly used in the tidyverse' packages.

--

__The difference should not worry you__, the main difference with a classical dataframe is the nicer output when printing (run `iris` in R to see the difference). 

--

By the way, note that a tibble __is a data.frame__


```r
is.data.frame(data_work)
```

```
## [1] TRUE
```



---

## An other package of the `tidyverse` : `readxl` to read .xlsx files

The function `read_xlsx` allows you to read .xlsx files.

--

Some arguments are useful for you:

* `sheet` : name of the sheet of the file you want to read (if you provide a string), or position of the sheet you want to read (if you provide an integer)
* same arguments as `read_csv` (`na`, `skip` etc.)
* see `?read_xlsx` for details.

---

# Exercises




---

## Manipulate your data using `dplyr`

`dplyr` is a package of the `tidyverse` designed to manipulate your data easily.


--

&gt; what do we mean by manipulating the data easily ?


--

Select columns, filter their rows, create new columns etc.

--

.center[![](lesson_figures/dplyr1.jpg)]

---

Let us consider the dataset `data_work` previously introduced (it is simply the well know `iris` dataset turned into tibble). 


```
## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  
##  1          5.1         3.5          1.4         0.2 setosa 
##  2          4.9         3            1.4         0.2 setosa 
##  3          4.7         3.2          1.3         0.2 setosa 
##  4          4.6         3.1          1.5         0.2 setosa 
##  5          5           3.6          1.4         0.2 setosa 
##  6          5.4         3.9          1.7         0.4 setosa 
##  7          4.6         3.4          1.4         0.3 setosa 
##  8          5           3.4          1.5         0.2 setosa 
##  9          4.4         2.9          1.4         0.2 setosa 
## 10          4.9         3.1          1.5         0.1 setosa 
## # ... with 140 more rows
```

Let's consider the manipulations we can do on this dataset.

---

## `dplyr::select`

In a data analysis, we could be interested in:

* *select* some columns, for instance:
  + *select* the 3rd column

--


```r
select(data_work, 3)
```

```
## # A tibble: 150 x 1
##    Petal.Length
##           &lt;dbl&gt;
##  1          1.4
##  2          1.4
##  3          1.3
##  4          1.5
##  5          1.4
##  6          1.7
##  7          1.4
##  8          1.5
##  9          1.4
## 10          1.5
## # ... with 140 more rows
```


---

## `dplyr::select`

In a data analysis, we could be interested in:

* *select* some columns, for instance:
  + *select* column Sepal.Width

--


```r
select(data_work, Sepal.Width)
```

```
## # A tibble: 150 x 1
##    Sepal.Width
##          &lt;dbl&gt;
##  1         3.5
##  2         3  
##  3         3.2
##  4         3.1
##  5         3.6
##  6         3.9
##  7         3.4
##  8         3.4
##  9         2.9
## 10         3.1
## # ... with 140 more rows
```

```r
# Note the absence of " around Sepal .Width
```

---

## `dplyr::select`

In a data analysis, we could be interested in:

* *select* some columns, for instance:
  + *select*  all columns except Sepal.width and Sepal.Length)
  
--


```r
select(data_work, - c(Sepal.Width, Sepal.Length))
```

```
## # A tibble: 150 x 3
##    Petal.Length Petal.Width Species
##           &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  
##  1          1.4         0.2 setosa 
##  2          1.4         0.2 setosa 
##  3          1.3         0.2 setosa 
##  4          1.5         0.2 setosa 
##  5          1.4         0.2 setosa 
##  6          1.7         0.4 setosa 
##  7          1.4         0.3 setosa 
##  8          1.5         0.2 setosa 
##  9          1.4         0.2 setosa 
## 10          1.5         0.1 setosa 
## # ... with 140 more rows
```

```r
#Note the absence of " around Sepal.Width and Sepal.Length,
#and the - that means except
```

---

## `dplyr::select`: helpers()

`select()` is provided with many *functions helpers* that you can use to select columns, for instance:

* `select(data_work, contains("pal"))`: all columns of `data_work` containing "pal"

--

* `select(data_work, starts_with("Se"))`: *can you guess it ?*

--

* `select(data_work, ends_with("th"))`: *can you guess it ?*

--

* `select(data_work, matches("*th"))`: *can you guess it ?* (select columns with name matching a regular expression)

--

&gt; That's one of the assets of the dplyr syntax: it looks like almost natural language.

---
  
## `dplyr::filter`

In a data analysis, we could be interested in:

* *filter* rows based on the values of some columns (predicates), for instance:
  + *filter* rows of `data_work` with individuals having their length of Sepal greater than 4

--

```r
filter(data_work, Sepal.Length &gt; 4)
```

```
## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  
##  1          5.1         3.5          1.4         0.2 setosa 
##  2          4.9         3            1.4         0.2 setosa 
##  3          4.7         3.2          1.3         0.2 setosa 
##  4          4.6         3.1          1.5         0.2 setosa 
##  5          5           3.6          1.4         0.2 setosa 
##  6          5.4         3.9          1.7         0.4 setosa 
##  7          4.6         3.4          1.4         0.3 setosa 
##  8          5           3.4          1.5         0.2 setosa 
##  9          4.4         2.9          1.4         0.2 setosa 
## 10          4.9         3.1          1.5         0.1 setosa 
## # ... with 140 more rows
```

---


## `dplyr::filter`

In a data analysis, we could be interested in:

* *filter* rows based on the values of some columns (predicates), for instance:
  + *filter* rows of `data_work` of species "virginica"

--


```r
filter(data_work, Species == "virginica")
```

```
## # A tibble: 50 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species  
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;    
##  1          6.3         3.3          6           2.5 virginica
##  2          5.8         2.7          5.1         1.9 virginica
##  3          7.1         3            5.9         2.1 virginica
##  4          6.3         2.9          5.6         1.8 virginica
##  5          6.5         3            5.8         2.2 virginica
##  6          7.6         3            6.6         2.1 virginica
##  7          4.9         2.5          4.5         1.7 virginica
##  8          7.3         2.9          6.3         1.8 virginica
##  9          6.7         2.5          5.8         1.8 virginica
## 10          7.2         3.6          6.1         2.5 virginica
## # ... with 40 more rows
```


---

## `dplyr::filter`
  
You can put multiple conditions, for instance:

* *filter* rows based on the values of some columns (predicates), for instance:
  + *filter* rows of `data_work` of species "virginica" and with their Width of Petal smaller than 2

--


```r
filter(data_work, Species == "virginica", Petal.Width &lt; 2)
```

```
## # A tibble: 21 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species  
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;    
##  1          5.8         2.7          5.1         1.9 virginica
##  2          6.3         2.9          5.6         1.8 virginica
##  3          4.9         2.5          4.5         1.7 virginica
##  4          7.3         2.9          6.3         1.8 virginica
##  5          6.7         2.5          5.8         1.8 virginica
##  6          6.4         2.7          5.3         1.9 virginica
##  7          6.5         3            5.5         1.8 virginica
##  8          6           2.2          5           1.5 virginica
##  9          6.3         2.7          4.9         1.8 virginica
## 10          7.2         3.2          6           1.8 virginica
## # ... with 11 more rows
```

---

&gt; Again, it looks like the natural language !

--

That's one of the nicer things in the `dplyr` syntax.

---

## `dplyr::mutate`

--

`mutate` is the verb used to create new columns.

--

For instance, suppose we want to compute the sum of the lengths of the Sepal and the Petal in our dataset.

--


```r
mutate(data_work, sum_lengths = Sepal.Length + Petal.Length)
```

```
## # A tibble: 150 x 6
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species sum_lengths
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;         &lt;dbl&gt;
##  1          5.1         3.5          1.4         0.2 setosa          6.5
##  2          4.9         3            1.4         0.2 setosa          6.3
##  3          4.7         3.2          1.3         0.2 setosa          6  
##  4          4.6         3.1          1.5         0.2 setosa          6.1
##  5          5           3.6          1.4         0.2 setosa          6.4
##  6          5.4         3.9          1.7         0.4 setosa          7.1
##  7          4.6         3.4          1.4         0.3 setosa          6  
##  8          5           3.4          1.5         0.2 setosa          6.5
##  9          4.4         2.9          1.4         0.2 setosa          5.8
## 10          4.9         3.1          1.5         0.1 setosa          6.4
## # ... with 140 more rows
```

---

## `dplyr`: other useful functions

--

`dplyr` provides many useful functions. You can guess their purposes just by their name:

* `arrange`
* `distinct`
* `rename`


---

# Chain commands using %&gt;% (pipe) operator

The %&gt;% (pronounce pipe) provides a convenient way to code, as it allows the code to be written in chain. 

.center[![](lesson_figures/this_is_not_a_pipe.jpg)]

---

For instance, suppose we want to:

1. *filter* rows of `data_work` of species "virginica" and with their Width of Petal smaller than 2
2. *then* compute the sum of the lengths of the Sepal and the Petal in our dataset.
3. *then* select the columns with their name starting with an `\(S\)`
4. *then* arrange the result by length of Sepal.Length

We would write

--


```r
arrange(select(mutate(filter(data_work, Species == 'virginica', Petal.Width &lt;2), Sum_lengths = Sepal.Length + Petal.Length), starts_with("S")), Sepal.Length)
```

--

&gt; Isn't it unreadable ?!

---

Let's write it using the %&gt;% operator:

--


```r
data_work %&gt;% 
  filter(Species == 'virginica', Petal.Width &lt; 2) %&gt;% 
  mutate(Sum_lengths = Sepal.Length + Petal.Length) %&gt;% 
  select(starts_with("S")) %&gt;% 
  arrange(Sepal.Length)
```


--


See how clearer it looks. 

If I run this: `x %&gt;% sum` it is strictly equivalent to `sum(x)`.

---

Another example to see the power of %&gt;%. Suppose I want to carry out the following steps:

1. Take `data_work`
2. Select variables containing "Sepal", and "Petal.Width" and "Species"
3. Filter rows with length of Sepal greater than 5
4. Fit a linear model of Petal.Width vs Sepal.Width + Sepal.Length + Species
5. Print a summary of the model


--


```r
data_work %&gt;% #Step 1
  select(contains("Sepal") ,
         Petal.Width, Species) %&gt;% # Step 2
  filter(Sepal.Length &gt;5) %&gt;% # Step 3
  lm(Petal.Width ~ Sepal.Width + Sepal.Length + Species,
     data= .) %&gt;% # Step 4: NOTE THE .
  summary # Step 5
```

```
## 
## Call:
## lm(formula = Petal.Width ~ Sepal.Width + Sepal.Length + Species, 
##     data = .)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.48660 -0.10718 -0.00351  0.12237  0.46503 
## 
## Coefficients:
##                   Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)       -1.14888    0.24851  -4.623 1.01e-05 ***
## Sepal.Width        0.31463    0.06437   4.888 3.40e-06 ***
## Sepal.Length       0.04850    0.03937   1.232     0.22    
## Speciesversicolor  1.32247    0.08861  14.924  &lt; 2e-16 ***
## Speciesvirginica   1.92157    0.09602  20.012  &lt; 2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.1902 on 113 degrees of freedom
## Multiple R-squared:  0.9225,	Adjusted R-squared:  0.9198 
## F-statistic: 336.4 on 4 and 113 DF,  p-value: &lt; 2.2e-16
```

---


```r
data_work %&gt;% #Step 1
  select(contains("Sepal") ,
         Petal.Width, Species) %&gt;% # Step 2
  filter(Sepal.Length &gt;5) %&gt;% # Step 3
  lm(Petal.Width ~ Sepal.Width + Sepal.Length + Species,
     data= .) %&gt;% # Step 4: NOTE THE .
  summary # Step 5
```

```
## 
## Call:
## lm(formula = Petal.Width ~ Sepal.Width + Sepal.Length + Species, 
##     data = .)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.48660 -0.10718 -0.00351  0.12237  0.46503 
## 
## Coefficients:
##                   Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)       -1.14888    0.24851  -4.623 1.01e-05 ***
## Sepal.Width        0.31463    0.06437   4.888 3.40e-06 ***
## Sepal.Length       0.04850    0.03937   1.232     0.22    
## Speciesversicolor  1.32247    0.08861  14.924  &lt; 2e-16 ***
## Speciesvirginica   1.92157    0.09602  20.012  &lt; 2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.1902 on 113 degrees of freedom
## Multiple R-squared:  0.9225,	Adjusted R-squared:  0.9198 
## F-statistic: 336.4 on 4 and 113 DF,  p-value: &lt; 2.2e-16
```

In this example, it is also important to notice the __.__ . When using the pipe, the "." is the object refering to what's before the last %&gt;% .

--

It is important to specify it when the argument that needs the object before the last %&gt;% is not the first argument.That's why we had to specify it in the `lm` function and not in the `select` function.

---

# Group operations

An important features of `dplyr` is its ability to *group* tibbles and compute operations on these *grouped* tibbles.

---


```r
data_work_by_species &lt;- data_work %&gt;%
  group_by(Species) 
# Equivalent to data_work_by_species &lt;- group_by(data_work, Species)

data_work_by_species
```

```
## # A tibble: 150 x 5
## # Groups:   Species [3]
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  
## 1          5.1         3.5          1.4         0.2 setosa 
## 2          4.9         3            1.4         0.2 setosa 
## 3          4.7         3.2          1.3         0.2 setosa 
## 4          4.6         3.1          1.5         0.2 setosa 
## 5          5           3.6          1.4         0.2 setosa 
## 6          5.4         3.9          1.7         0.4 setosa 
## # ... with 144 more rows
```

--

Not the `# Groups:   Species [3]`. It means that operations on this dataset will be done for each group.

---

For example, suppose we want to compute the median of the width of the Sepal for each species.


```r
data_work_by_species %&gt;%
  mutate(median_sepal_width = median(Sepal.Width)) %&gt;% 
  select(starts_with("S"), median_sepal_width)
```

```
## # A tibble: 150 x 4
## # Groups:   Species [3]
##   Sepal.Length Sepal.Width Species median_sepal_width
##          &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;
## 1          5.1         3.5 setosa                 3.4
## 2          4.9         3   setosa                 3.4
## 3          4.7         3.2 setosa                 3.4
## 4          4.6         3.1 setosa                 3.4
## 5          5           3.6 setosa                 3.4
## 6          5.4         3.9 setosa                 3.4
## # ... with 144 more rows
```

It's nice, but we may also need to summarise the table, just keep a summary of the Species and the median.

---

`dplyr::summarise`

It is easily done by the function `summarise`

--


```r
data_work_by_species %&gt;%
  summarise(median_sepal_width = median(Sepal.Width)) 
```

```
## # A tibble: 3 x 2
##   Species    median_sepal_width
##   &lt;chr&gt;                   &lt;dbl&gt;
## 1 setosa                    3.4
## 2 versicolor                2.8
## 3 virginica                 3
```


---

If you want to take out the grouped structure of you tibble, you just have to use the function `ungroup`


```r
data_work_by_species %&gt;% ungroup
```

```
## # A tibble: 150 x 5
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;  
## 1          5.1         3.5          1.4         0.2 setosa 
## 2          4.9         3            1.4         0.2 setosa 
## 3          4.7         3.2          1.3         0.2 setosa 
## 4          4.6         3.1          1.5         0.2 setosa 
## 5          5           3.6          1.4         0.2 setosa 
## 6          5.4         3.9          1.7         0.4 setosa 
## # ... with 144 more rows
```


---


Exercises

---

# Tidy data

1. Each variable must have its own column
2. Each observation must have its row
3. Each value must have its own cell

![](lesson_figures/tidy-1.png)

---



--

For instance, imagine this dataset, giving the population of different countries in 2002 and 2007:


```r
d %&gt;% head
```

```
## # A tibble: 6 x 3
##   country       `2002`   `2007`
##   &lt;chr&gt;          &lt;dbl&gt;    &lt;dbl&gt;
## 1 Belgium     10311970 10392226
## 2 France      59925035 61083916
## 3 Germany     82350671 82400996
## 4 Italy       57926999 58147733
## 5 Spain       40152517 40448191
## 6 Switzerland  7361757  7554661
```

--

* Is this dataset tidy ?

--

This is dataset is __not__ tidy, as the population, which is an observed variable is not in a distinct column (principle 1.). Year is also a variable, so it should have its column to.

---

Instead, we should have:



```
## # A tibble: 6 x 3
##   country year  population
##   &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt;
## 1 Belgium 2002    10311970
## 2 Belgium 2007    10392226
## 3 France  2002    59925035
## 4 France  2007    61083916
## 5 Germany 2002    82350671
## 6 Germany 2007    82400996
```


---

### Make tidy data

* `tidyr::pivot_longer` is used to make your dataset *longer* (what a surprise ! :O)
* `tidyr::pivot_wider` is used to make your dataset *wider* (what a surprise ! :O)



---

In practice:


```r
#d is the dataset with the populations of the countries
data_tidy &lt;- d %&gt;% pivot_longer(cols =  c(`2002`,`2007`))

head(data_tidy)
```

```
## # A tibble: 6 x 3
##   country name     value
##   &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;
## 1 Belgium 2002  10311970
## 2 Belgium 2007  10392226
## 3 France  2002  59925035
## 4 France  2007  61083916
## 5 Germany 2002  82350671
## 6 Germany 2007  82400996
```

The first argument is the dataset to tidy (which is not necessary to complete because of the %&gt;% ). The second is the name of the columns to gather.

We can also provide



&lt;!-- ### `tidyr::pivot_longer` and `tidyr::pivot_wider` --&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
